<!DOCTYPE html>
<html lang="zh-TW">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>1943: Midway Battle (Ultimate)</title>
	<style>
		body {
			margin: 0;
			overflow: hidden;
			background-color: #051020;
			color: white;
			font-family: 'Segoe UI', sans-serif;
			touch-action: none;
			user-select: none;
		}

		canvas {
			display: block;
		}

		#ui {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
		}

		.screen {
			background: rgba(10, 20, 40, 0.95);
			border: 4px double #ffaa00;
			padding: 2rem;
			border-radius: 4px;
			text-align: center;
			pointer-events: auto;
			box-shadow: 0 0 30px rgba(255, 170, 0, 0.3);
			min-width: 300px;
		}

		.hidden {
			display: none !important;
		}

		h1 {
			color: #ffaa00;
			font-family: 'Impact', sans-serif;
			letter-spacing: 5px;
			font-size: 3rem;
			text-transform: uppercase;
			margin: 0 0 1rem 0;
			text-shadow: 3px 3px 0 #000;
		}

		p {
			color: #ccc;
			margin-bottom: 2rem;
			font-size: 1.2rem;
			font-weight: bold;
			line-height: 1.5;
		}

		button {
			background: #aa0000;
			border: 2px solid #ff5500;
			padding: 10px 40px;
			color: #fff;
			font-size: 1.5rem;
			font-weight: bold;
			cursor: pointer;
			transition: 0.2s;
			text-transform: uppercase;
			font-family: 'Courier New', monospace;
		}

		button:hover {
			background: #ff0000;
			transform: scale(1.05);
			box-shadow: 0 0 15px #ff0000;
			filter: brightness(1.2);
		}

		/* Difficulty Buttons */
		.diff-btn {
			transition: all 0.2s;
			opacity: 0.6;
		}
		.diff-btn:hover {
			opacity: 1;
			transform: scale(1.05);
			background: inherit !important;
		}
		.diff-btn.selected {
			opacity: 1;
			transform: scale(1.1);
			box-shadow: 0 0 15px currentColor;
		}

		/* HUD */
		#hud-top {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 80px;
			display: flex;
			justify-content: space-between;
			padding: 10px 20px;
			box-sizing: border-box;
			z-index: 10;
			font-family: 'Consolas', 'Courier New', monospace;
			font-weight: bold;
			text-shadow: 2px 2px 0 #000;
			pointer-events: none;
		}

		.hud-col {
			display: flex;
			flex-direction: column;
			gap: 5px;
		}

		.hud-big {
			font-size: 1.5rem;
			color: #fff;
		}

		.hud-label {
			font-size: 0.9rem;
			color: #aaa;
		}

		#fuel-bar-frame {
			width: 150px;
			height: 15px;
			border: 2px solid #fff;
			background: #222;
			margin-top: 5px;
		}

		#fuel-bar-fill {
			width: 100%;
			height: 100%;
			background: linear-gradient(90deg, #ffcc00, #ff5500);
			transition: width 0.2s;
		}

		#active-weapons {
			display: flex;
			gap: 5px;
			margin-top: 5px;
		}

		.weapon-badge {
			width: 20px;
			height: 20px;
			border-radius: 50%;
			border: 1px solid white;
			font-size: 12px;
			display: flex;
			align-items: center;
			justify-content: center;
			color: black;
			font-weight: bold;
		}

		/* Boss Bar */
		#boss-ui {
			position: absolute;
			top: 100px;
			left: 50%;
			transform: translateX(-50%);
			width: 60%;
			max-width: 500px;
			display: none;
			z-index: 100;
			pointer-events: none;
			text-align: center;
		}

		#boss-name {
			color: #ff0055;
			font-weight: 900;
			font-size: 2rem;
			text-shadow: 3px 3px 0 #000;
			letter-spacing: 2px;
			font-family: 'Impact', sans-serif;
			text-transform: uppercase;
			margin-bottom: 5px;
		}

		#boss-sub {
			color: #fff;
			font-size: 1rem;
			margin-bottom: 5px;
			text-shadow: 1px 1px 0 #000;
		}

		#boss-bar-frame {
			width: 100%;
			height: 25px;
			border: 3px solid #fff;
			background: #000;
			box-shadow: 0 0 15px #aa0000;
		}

		#boss-bar-fill {
			width: 100%;
			height: 100%;
			background: linear-gradient(90deg, #aa0000, #ff0000);
			transition: width 0.1s;
		}

		/* Effects */
		#flash {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: white;
			pointer-events: none;
			opacity: 0;
			transition: opacity 0.1s;
			z-index: 90;
		}

		#mega-crash-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: cyan;
			pointer-events: none;
			opacity: 0;
			z-index: 85;
			mix-blend-mode: hard-light;
		}

		/* Center Messages (Mission Start / Warning) */
		.center-msg {
			position: absolute;
			top: 35%;
			width: 100%;
			text-align: center;
			font-size: 4rem;
			font-weight: 900;
			color: #ffcc00;
			text-shadow: 4px 4px 0 #aa0000;
			font-family: 'Impact', sans-serif;
			pointer-events: none;
			animation: popUp 2.5s forwards;
			z-index: 80;
		}

		@keyframes popUp {
			0% {
				transform: scale(0) translateY(50px);
				opacity: 0;
			}

			15% {
				transform: scale(1.2) translateY(0);
				opacity: 1;
			}

			80% {
				opacity: 1;
			}

			100% {
				transform: scale(1.5);
				opacity: 0;
			}
		}

		/* Mobile Controls */
		#mobile-controls {
			position: absolute;
			bottom: 20px;
			right: 20px;
			display: none;
			z-index: 50;
		}

		.btn-circle {
			width: 80px;
			height: 80px;
			border-radius: 50%;
			background: rgba(255, 0, 0, 0.5);
			border: 2px solid white;
			color: white;
			font-weight: bold;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 1.2rem;
			user-select: none;
		}

		.btn-circle:active {
			background: rgba(255, 0, 0, 0.8);
		}

		@media (hover: none) and (pointer: coarse) {
			#mobile-controls {
				display: block;
			}
		}

		#sound-btn {
			position: fixed;
			top: 10px;
			right: 10px;
			width: 45px;
			height: 45px;
			font-size: 22px;
			background: rgba(0, 0, 0, 0.5);
			border: 2px solid #fff;
			border-radius: 8px;
			color: white;
			cursor: pointer;
			z-index: 200;
			padding: 0;
			line-height: 45px;
		}

		#sound-btn:hover {
			background: rgba(255, 255, 255, 0.2);
		}
	</style>
</head>

<body>
	<div id="flash"></div>
	<div id="mega-crash-overlay"></div>

	<div id="hud-top">
		<div class="hud-col">
			<div class="hud-big" style="color:#ffcc00">SCORE <span id="score">0</span></div>
			<div class="hud-label">HI-SCORE <span id="hiscore">0</span></div>
		</div>
		<div class="hud-col" style="align-items: center;">
			<div class="hud-label">STAGE</div>
			<div class="hud-big" id="stage-display">1</div>
			<div class="hud-label" id="difficulty-display" style="margin-top:5px;">æ™®é€š</div>
		</div>
		<div class="hud-col" style="align-items: flex-end;">
			<div class="hud-label">FUEL (SPECIAL)</div>
			<div id="fuel-bar-frame">
				<div id="fuel-bar-fill"></div>
			</div>
			<div class="hud-big" style="color:#00ffff" id="lives-display">â¤â¤â¤</div>
			<div id="active-weapons"></div>
		</div>
	</div>

	<div id="msg-container"></div>

	<div id="boss-ui">
		<div id="boss-name">YAMATO</div>
		<div id="boss-sub">Imperial Flagship</div>
		<div id="boss-bar-frame">
			<div id="boss-bar-fill"></div>
		</div>
	</div>

	<canvas id="gameCanvas"></canvas>

	<div id="mobile-controls">
		<div class="btn-circle" ontouchstart="triggerSpecial(event)">âš¡</div>
	</div>

	<button id="sound-btn" onclick="toggleSound()">ğŸ”Š</button>

	<div id="ui">
		<div id="start-screen" class="screen">
			<h1>1943: MIDWAY</h1>
			<p>ULTIMATE EDITION</p>
			<p style="font-size:1rem; margin-bottom:10px;">
				<b>WASD / æ–¹å‘éµ</b> ç§»å‹•<br>
				<b>SPACE / Z</b> ç‰¹æ®ŠæŠ€èƒ½<br>
				<b>ESC / P</b> æš«åœ
			</p>
			<div style="margin-bottom:15px;">
				<label style="color:#ffaa00; display:block; margin-bottom:8px;">é›£åº¦é¸æ“‡ï¼š</label>
				<div id="difficulty-buttons" style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap;">
					<button class="diff-btn" data-diff="easy" style="background:#1a3a1a; border:2px solid #00ff00; color:#00ff00; padding:8px 12px; cursor:pointer; border-radius:4px;">
						<div style="font-weight:bold;">ç°¡å–®</div>
						<div style="font-size:0.7rem; opacity:0.8;">HPÃ—0.7 | 5å‘½</div>
					</button>
					<button class="diff-btn selected" data-diff="normal" style="background:#3a3a1a; border:2px solid #ffff00; color:#ffff00; padding:8px 12px; cursor:pointer; border-radius:4px;">
						<div style="font-weight:bold;">æ™®é€š</div>
						<div style="font-size:0.7rem; opacity:0.8;">HPÃ—1.0 | 3å‘½</div>
					</button>
					<button class="diff-btn" data-diff="hard" style="background:#3a2a1a; border:2px solid #ff8800; color:#ff8800; padding:8px 12px; cursor:pointer; border-radius:4px;">
						<div style="font-weight:bold;">å›°é›£</div>
						<div style="font-size:0.7rem; opacity:0.8;">HPÃ—1.5 | 3å‘½</div>
					</button>
					<button class="diff-btn" data-diff="arcade" style="background:#3a1a1a; border:2px solid #ff0000; color:#ff0000; padding:8px 12px; cursor:pointer; border-radius:4px;">
						<div style="font-weight:bold;">è¡—æ©Ÿ</div>
						<div style="font-size:0.7rem; opacity:0.8;">HPÃ—2.0 | 1å‘½</div>
					</button>
				</div>
				<div id="difficulty-desc" style="margin-top:10px; font-size:0.85rem; color:#aaa; min-height:40px;">
					æ¨™æº–é›£åº¦ï¼Œé©åˆå¤§å¤šæ•¸ç©å®¶
				</div>
			</div>
			<div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 15px; font-size:0.9rem;">
				<span style="color:#0f0">Shotgun</span>
				<span style="color:#ff0">3-Way</span>
				<span style="color:#fff">Auto</span>
				<span style="color:#f00">Shell</span>
				<span style="color:#0ff">Laser</span>
			</div>
			<button onclick="startGame()">SCRAMBLE</button>
		</div>
		<div id="end-screen" class="screen hidden">
			<h1 style="color:#ff0055">MISSION FAILED</h1>
			<p>é›£åº¦: <span id="end-difficulty" style="font-weight:bold;">æ™®é€š</span></p>
			<p>SCORE: <span id="final-score">0</span></p>
			<p style="color:#ffaa00">MAX COMBO: <span id="final-combo">0</span></p>
			<p style="color:#888; font-size:0.9rem;">STAGE: <span id="final-stage">1</span></p>
			<button onclick="startGame()">RETRY</button>
		</div>
		<div id="win-screen" class="screen hidden">
			<h1 style="color:#00ff00">VICTORY</h1>
			<p>You have sunk the entire fleet!</p>
			<p>é›£åº¦: <span id="win-difficulty" style="font-weight:bold;">æ™®é€š</span></p>
			<p>FINAL SCORE: <span id="final-win-score">0</span></p>
			<p style="color:#ffaa00">MAX COMBO: <span id="final-win-combo">0</span></p>
			<button onclick="startGame()">PLAY AGAIN</button>
		</div>
	</div>

	<script>
		// --- 1943 Data (Based on Original Arcade) ---
		const BOSS_DATA = [
			// Stage 1: åˆ©æ ¹ (é‡å·¡æ´‹è‰¦) - å‰2ç ² + å´é¢4é«˜å°„ç ²
			{
				name: "TONE", type: "Heavy Cruiser", hp: 3000, w: 120, h: 250, enter: 'top', parts: [
					{ t: 'turret_main', x: 0, y: -60, cd: 60 },
					{ t: 'turret_main', x: 0, y: 40, cd: 70 },
					{ t: 'turret_aa', x: -40, y: -20, cd: 40 },
					{ t: 'turret_aa', x: 40, y: -20, cd: 45 },
					{ t: 'turret_aa', x: -40, y: 60, cd: 50 },
					{ t: 'turret_aa', x: 40, y: 60, cd: 55 }
				]
			},
			// Stage 2: åŠ è³€ (èˆªç©ºæ¯è‰¦) - ç”²æ¿æ”¾é£›æ©Ÿ + é«˜å°„ç ²
			{
				name: "KAGA", type: "Aircraft Carrier", hp: 4500, w: 160, h: 320, enter: 'top', parts: [
					{ t: 'bridge', x: 50, y: -20 },
					{ t: 'deck', x: 0, y: 50 },
					{ t: 'turret_aa', x: 60, y: 40, cd: 30 },
					{ t: 'turret_aa', x: 60, y: -80, cd: 35 }
				]
			},
			// Stage 3: ç¶¾å­ä¸€å‹ (å¤§å‹è½Ÿç‚¸æ©Ÿ) - 3ç™¼æŸ±ç‹€/5ç™¼æ‰‡å½¢
			{
				name: "AYAKO", type: "Super Bomber", hp: 5000, w: 280, h: 180, enter: 'bottom', parts: [
					{ t: 'propeller', x: -80, y: 10, spd: 0.5 },
					{ t: 'propeller', x: 80, y: 10, spd: -0.5 },
					{ t: 'propeller', x: -40, y: 20, spd: 0.5 },
					{ t: 'propeller', x: 40, y: 20, spd: -0.5 },
					{ t: 'turret_aa', x: 0, y: 70, cd: 45 } // Reduced fire rate for mobile
				]
			},
			// Stage 4: æ‰¶æ¡‘ (æˆ°è‰¦) - é˜²ç¦¦è¼ƒå¼±
			{
				name: "FUSO", type: "Battleship", hp: 6000, w: 140, h: 320, enter: 'top', parts: [
					{ t: 'turret_main', x: 0, y: -80, cd: 70 },
					{ t: 'turret_main', x: 0, y: -30, cd: 80 },
					{ t: 'bridge', x: 0, y: 20 },
					{ t: 'turret_main', x: 0, y: 80, cd: 90 }
				]
			},
			// Stage 5: èµ¤åŸ (èˆªç©ºæ¯è‰¦) - å¯†é›†é«˜å°„ç ² + 2æ”¾é£›æ©Ÿå¹³å°
			{
				name: "AKAGI", type: "Aircraft Carrier", hp: 8000, w: 180, h: 360, enter: 'top', parts: [
					{ t: 'bridge', x: -60, y: 0 },
					{ t: 'deck', x: 0, y: -60 },
					{ t: 'deck', x: 0, y: 80 },
					{ t: 'turret_aa', x: -60, y: -80, cd: 25 },
					{ t: 'turret_aa', x: -60, y: 80, cd: 25 },
					{ t: 'turret_aa', x: 60, y: -40, cd: 20 },
					{ t: 'turret_aa', x: 60, y: 40, cd: 20 }
				]
			},
			// Stage 6: å¤§é£›é¾ä¸€å‹ (æ•µæ©Ÿç·¨éšŠ) - ç©ºæˆ°é—œå¡
			{
				name: "DAIHIRYU", type: "Air Squadron", hp: 6000, w: 300, h: 200, enter: 'bottom', parts: [
					{ t: 'propeller', x: -100, y: 0, spd: 0.6 },
					{ t: 'propeller', x: 100, y: 0, spd: -0.6 },
					{ t: 'propeller', x: 0, y: 0, spd: 0.4 },
					{ t: 'turret_aa', x: -50, y: 60, cd: 35 },
					{ t: 'turret_aa', x: 50, y: 60, cd: 38 },
					{ t: 'turret_aa', x: 0, y: 80, cd: 30 }
				]
			},
			// Stage 7: ä¼Šå‹¢ (èˆªç©ºæˆ°è‰¦) - 4é–€å¤§ç ² + æ”¾æˆ°é¬¥æ©Ÿ
			{
				name: "ISE", type: "Aviation Battleship", hp: 10000, w: 160, h: 340, enter: 'top', parts: [
					{ t: 'turret_main', x: 0, y: -100, cd: 50 },
					{ t: 'turret_main', x: 0, y: -50, cd: 55 },
					{ t: 'bridge', x: 0, y: 0 },
					{ t: 'deck', x: 0, y: 80 },
					{ t: 'turret_main', x: 0, y: 120, cd: 60 }
				]
			},
			// Stage 8: é£›é¾ (èˆªç©ºæ¯è‰¦) - å¯†é›†é«˜å°„ç ²
			{
				name: "HIRYU", type: "Aircraft Carrier", hp: 11000, w: 160, h: 340, enter: 'top', parts: [
					{ t: 'bridge', x: 50, y: 0 },
					{ t: 'deck', x: -20, y: 0 },
					{ t: 'turret_aa', x: 60, y: -60, cd: 18 },
					{ t: 'turret_aa', x: 60, y: 60, cd: 18 },
					{ t: 'turret_aa', x: -60, y: -40, cd: 22 },
					{ t: 'turret_aa', x: -60, y: 40, cd: 22 }
				]
			},
			// Stage 9: ç¶¾å­äºŒå‹ (å¼·åŒ–è½Ÿç‚¸æ©Ÿ) - 4æ¢è¡€ã€æ›´å¿«
			{
				name: "AYAKO II", type: "Super Bomber Mk.II", hp: 12000, w: 320, h: 220, enter: 'bottom', parts: [
					{ t: 'propeller', x: -110, y: 0, spd: 0.7 },
					{ t: 'propeller', x: 110, y: 0, spd: -0.7 },
					{ t: 'propeller', x: -50, y: 10, spd: 0.6 },
					{ t: 'propeller', x: 50, y: 10, spd: -0.6 },
					{ t: 'turret_main', x: 0, y: 0, cd: 45 },
					{ t: 'turret_aa', x: -60, y: 70, cd: 15 },
					{ t: 'turret_aa', x: 60, y: 70, cd: 15 }
				]
			},
			// Stage 10: é™¸å¥§ (æˆ°è‰¦) - å¤§ç ² + å¯†é›†é«˜å°„ç ²
			{
				name: "MUTSU", type: "Battleship", hp: 14000, w: 180, h: 360, enter: 'top', parts: [
					{ t: 'turret_main', x: 0, y: -100, cd: 45 },
					{ t: 'turret_main', x: 0, y: -50, cd: 50 },
					{ t: 'bridge', x: 0, y: 0 },
					{ t: 'turret_main', x: 0, y: 60, cd: 55 },
					{ t: 'turret_main', x: 0, y: 110, cd: 60 },
					{ t: 'turret_aa', x: -50, y: 20, cd: 20 },
					{ t: 'turret_aa', x: 50, y: 20, cd: 20 }
				]
			},
			// Stage 11: å¤§é£›é¾äºŒå‹ (å¼·åŒ–ç·¨éšŠ) - æœƒæ”¾è¡æ’æˆ°é¬¥æ©Ÿ
			{
				name: "DAIHIRYU II", type: "Air Squadron II", hp: 13000, w: 340, h: 240, enter: 'bottom', parts: [
					{ t: 'propeller', x: -120, y: -20, spd: 0.8 },
					{ t: 'propeller', x: 120, y: -20, spd: -0.8 },
					{ t: 'propeller', x: -60, y: 0, spd: 0.7 },
					{ t: 'propeller', x: 60, y: 0, spd: -0.7 },
					{ t: 'turret_aa', x: 0, y: 0, cd: 12 },
					{ t: 'turret_aa', x: -80, y: 60, cd: 14 },
					{ t: 'turret_aa', x: 80, y: 60, cd: 14 },
					{ t: 'turret_aa', x: 0, y: 90, cd: 10 }
				]
			},
			// Stage 12: å±±åŸ (æˆ°è‰¦)
			{
				name: "YAMASHIRO", type: "Battleship", hp: 16000, w: 180, h: 380, enter: 'top', parts: [
					{ t: 'turret_main', x: 0, y: -110, cd: 40 },
					{ t: 'turret_main', x: 0, y: -60, cd: 45 },
					{ t: 'bridge', x: 0, y: 0 },
					{ t: 'turret_main', x: 0, y: 70, cd: 50 },
					{ t: 'turret_main', x: 0, y: 120, cd: 55 },
					{ t: 'turret_aa', x: -50, y: -30, cd: 18 },
					{ t: 'turret_aa', x: 50, y: -30, cd: 18 }
				]
			},
			// Stage 13: è’¼é¾ (èˆªç©ºæ¯è‰¦) - å¤–è§€åŒé£›é¾
			{
				name: "SORYU", type: "Aircraft Carrier", hp: 18000, w: 170, h: 350, enter: 'top', parts: [
					{ t: 'bridge', x: -55, y: -10 },
					{ t: 'deck', x: 20, y: 0 },
					{ t: 'turret_aa', x: -55, y: -80, cd: 15 },
					{ t: 'turret_aa', x: -55, y: 70, cd: 15 },
					{ t: 'turret_aa', x: 55, y: -50, cd: 18 },
					{ t: 'turret_aa', x: 55, y: 50, cd: 18 }
				]
			},
			// Stage 14: ç¶¾å­ä¸‰å‹ (æœ€å¼·è½Ÿç‚¸æ©Ÿ) - 5æ¢è¡€ã€æ›´å¿«æ›´çŒ›
			{
				name: "AYAKO III", type: "Super Bomber Mk.III", hp: 20000, w: 350, h: 250, enter: 'bottom', parts: [
					{ t: 'propeller', x: -130, y: -10, spd: 0.9 },
					{ t: 'propeller', x: 130, y: -10, spd: -0.9 },
					{ t: 'propeller', x: -70, y: 10, spd: 0.8 },
					{ t: 'propeller', x: 70, y: 10, spd: -0.8 },
					{ t: 'propeller', x: 0, y: 20, spd: 0.7 },
					{ t: 'turret_main', x: 0, y: -20, cd: 35 },
					{ t: 'turret_aa', x: -80, y: 80, cd: 12 },
					{ t: 'turret_aa', x: 80, y: 80, cd: 12 },
					{ t: 'turret_aa', x: 0, y: 100, cd: 10 }
				]
			},
			// Stage 15: é•·é–€ (æˆ°è‰¦) - 6è‰˜è­·è¡›è‰¦
			{
				name: "NAGATO", type: "Battleship", hp: 25000, w: 200, h: 400, enter: 'top', parts: [
					{ t: 'turret_main', x: 0, y: -130, cd: 35 },
					{ t: 'turret_main', x: 0, y: -80, cd: 38 },
					{ t: 'bridge', x: 0, y: -20 },
					{ t: 'turret_main', x: 0, y: 50, cd: 40 },
					{ t: 'turret_main', x: 0, y: 100, cd: 42 },
					{ t: 'turret_aa', x: -60, y: -50, cd: 12 },
					{ t: 'turret_aa', x: 60, y: -50, cd: 12 },
					{ t: 'turret_aa', x: -60, y: 30, cd: 14 },
					{ t: 'turret_aa', x: 60, y: 30, cd: 14 }
				]
			},
			// Stage 16: å¤§å’Œ (æœ€çµ‚Boss) - é«˜å¨åŠ›ä¸»ç ² + å¤§é‡é«˜å°„ç ²
			{
				name: "YAMATO", type: "Imperial Flagship", hp: 35000, w: 240, h: 480, enter: 'top', parts: [
					{ t: 'turret_main', x: 0, y: -160, cd: 30 },
					{ t: 'turret_main', x: 0, y: -100, cd: 32 },
					{ t: 'turret_aa', x: -70, y: -130, cd: 10 },
					{ t: 'turret_aa', x: 70, y: -130, cd: 10 },
					{ t: 'bridge', x: 0, y: -30 },
					{ t: 'turret_aa', x: -70, y: -50, cd: 8 },
					{ t: 'turret_aa', x: 70, y: -50, cd: 8 },
					{ t: 'turret_aa', x: -70, y: 30, cd: 8 },
					{ t: 'turret_aa', x: 70, y: 30, cd: 8 },
					{ t: 'turret_main', x: 0, y: 80, cd: 35 },
					{ t: 'turret_main', x: 0, y: 140, cd: 38 }
				]
			}
		];

		const WEAPONS = {
			'NORMAL': { color: '#ffffaa', label: 'NORMAL' },
			'SHOTGUN': { color: '#00ff00', label: 'SHOTGUN' }, // S
			'3WAY': { color: '#ffff00', label: '3-WAY' },     // 3
			'AUTO': { color: '#ffffff', label: 'AUTO' },       // A
			'SHELL': { color: '#ff5500', label: 'SHELL' },     // M
			'LASER': { color: '#00ccff', label: 'LASER' }      // L
		};

		// === éŸ³æ•ˆç³»çµ± (Web Audio API) ===
		const SFX = {
			ctx: null,
			enabled: true,
			volume: 0.4,
			lastShoot: 0,

			init() {
				if (this.ctx) return;
				try {
					this.ctx = new (window.AudioContext || window.webkitAudioContext)();
				} catch (e) {
					this.enabled = false;
				}
			},

			tone(freq, dur, type = 'square', vol = 0.3) {
				if (!this.enabled || !this.ctx) return;
				const osc = this.ctx.createOscillator();
				const gain = this.ctx.createGain();
				osc.type = type;
				osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
				gain.gain.setValueAtTime(vol * this.volume, this.ctx.currentTime);
				gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
				osc.connect(gain);
				gain.connect(this.ctx.destination);
				osc.start();
				osc.stop(this.ctx.currentTime + dur);
			},

			noise(dur, vol = 0.3) {
				if (!this.enabled || !this.ctx) return;
				const bufferSize = this.ctx.sampleRate * dur;
				const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
				const data = buffer.getChannelData(0);
				for (let i = 0; i < bufferSize; i++) {
					data[i] = Math.random() * 2 - 1;
				}
				const noise = this.ctx.createBufferSource();
				noise.buffer = buffer;
				const gain = this.ctx.createGain();
				gain.gain.setValueAtTime(vol * this.volume, this.ctx.currentTime);
				gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
				noise.connect(gain);
				gain.connect(this.ctx.destination);
				noise.start();
			},

			// å°„æ“ŠéŸ³æ•ˆ
			shoot() {
				const now = Date.now();
				if (now - this.lastShoot < 50) return;
				this.lastShoot = now;
				this.tone(800, 0.04, 'square', 0.12);
			},
			laser() { this.tone(1000, 0.06, 'sawtooth', 0.15); this.tone(1200, 0.08, 'sine', 0.1); },
			shell() { this.tone(150, 0.15, 'sawtooth', 0.25); this.noise(0.08, 0.2); },

			// çˆ†ç‚¸éŸ³æ•ˆ
			explodeSmall() { this.noise(0.12, 0.2); this.tone(80, 0.08, 'square', 0.15); },
			explodeLarge() { this.noise(0.25, 0.35); this.tone(60, 0.15, 'square', 0.2); this.tone(40, 0.2, 'sine', 0.15); },
			explodeBoss() {
				this.noise(0.5, 0.5);
				this.tone(50, 0.3, 'square', 0.3);
				setTimeout(() => { this.noise(0.3, 0.4); this.tone(30, 0.25, 'sine', 0.25); }, 150);
				setTimeout(() => { this.noise(0.4, 0.35); }, 350);
			},

			// é“å…·éŸ³æ•ˆ
			powerup() { this.tone(600, 0.08, 'square', 0.2); this.tone(800, 0.08, 'square', 0.2); setTimeout(() => this.tone(1000, 0.12, 'square', 0.25), 80); },
			upgrade() { this.tone(500, 0.06, 'square', 0.2); this.tone(700, 0.06, 'square', 0.2); this.tone(900, 0.06, 'square', 0.2); setTimeout(() => this.tone(1200, 0.15, 'sine', 0.3), 150); },

			// Boss è­¦å‘Š
			warning() {
				const beep = () => { this.tone(440, 0.15, 'square', 0.35); };
				beep(); setTimeout(beep, 300); setTimeout(beep, 600);
			},

			// ç‰¹æ®ŠæŠ€èƒ½
			special() { this.noise(0.3, 0.4); this.tone(200, 0.2, 'sawtooth', 0.3); this.tone(400, 0.3, 'sine', 0.25); setTimeout(() => this.tone(100, 0.4, 'square', 0.2), 200); },

			// ç©å®¶è¢«æ“Šä¸­
			playerHit() { this.noise(0.2, 0.4); this.tone(200, 0.15, 'sawtooth', 0.35); this.tone(100, 0.2, 'square', 0.3); },

			// éŠæˆ²çµæŸ
			gameOver() {
				this.tone(400, 0.3, 'square', 0.3);
				setTimeout(() => this.tone(300, 0.3, 'square', 0.3), 300);
				setTimeout(() => this.tone(200, 0.5, 'square', 0.35), 600);
			},

			// ä»»å‹™é–‹å§‹
			missionStart() {
				this.tone(400, 0.1, 'square', 0.25);
				setTimeout(() => this.tone(500, 0.1, 'square', 0.25), 100);
				setTimeout(() => this.tone(600, 0.15, 'square', 0.3), 200);
				setTimeout(() => this.tone(800, 0.2, 'sine', 0.35), 350);
			},

			toggle() {
				this.enabled = !this.enabled;
				return this.enabled;
			}
		};

		const canvas = document.getElementById('gameCanvas');
		const ctx = canvas.getContext('2d');
		let width, height;

		// --- Game Config ---
		const PLAYER_SPEED = 0.2;
		const MAX_FUEL = 100;
		const KEY_SPEED = 6;

		// --- Difficulty Settings ---
		const DIFFICULTY_PRESETS = {
			easy:   { name: 'ç°¡å–®', hpMult: 0.7, bulletMult: 0.8, lives: 5, color: '#00ff00' },
			normal: { name: 'æ™®é€š', hpMult: 1.0, bulletMult: 1.0, lives: 3, color: '#ffff00' },
			hard:   { name: 'å›°é›£', hpMult: 1.5, bulletMult: 1.2, lives: 3, color: '#ff8800' },
			arcade: { name: 'è¡—æ©Ÿ', hpMult: 2.0, bulletMult: 1.5, lives: 1, color: '#ff0000' },
		};
		let currentDifficulty = 'normal';
		let difficultyMult = 1.0;    // Enemy HP multiplier
		let bulletSpeedMult = 1.0;   // Enemy bullet speed multiplier
		let startingLives = 3;

		// --- State ---
		let gameRunning = false;
		let paused = false;
		let frame = 0;
		let score = 0;
		let hiscore = localStorage.getItem('endless_hiscore') || 0;
		let stage = 1;
		let bossActive = false;
		let bgOffset = 0;
		let nextBossTrigger = 0;
		let bgScrollSpeed = 3;
		let shake = 0;

		// --- Combo System ---
		let combo = 0;
		let comboTimer = 0;
		let maxCombo = 0;
		const COMBO_TIMEOUT = 120; // 2 seconds at 60fps

		// --- Boss Warning System ---
		let bossWarning = false;
		let bossWarningTimer = 0;
		let bossWarningData = null;
		const BOSS_WARNING_DURATION = 180; // 3 seconds at 60fps

		// --- Stage Transition System ---
		let stageTransition = false;
		let stageTransitionTimer = 0;
		const STAGE_TRANSITION_DURATION = 180; // 3 seconds at 60fps

		// Stage names based on 1943 original
		const STAGE_NAMES = [
			{ name: "å‡ºæ’ƒ", area: "å¤ªå¹³æ´‹ä¸Šç©º", mission: "æ•µè‰¦éšŠã‚’ç™ºè¦‹ã›ã‚ˆ" },
			{ name: "é­é‡", area: "ãƒŸãƒƒãƒ‰ã‚¦ã‚§ãƒ¼æ²–", mission: "æ•µç©ºæ¯ã‚’æ’ƒæ²ˆã›ã‚ˆ" },
			{ name: "å¼·è¥²", area: "æ•µè‰¦éšŠä¸Šç©º", mission: "æ•µçˆ†æ’ƒæ©Ÿã‚’æ’ƒå¢œã›ã‚ˆ" },
			{ name: "æ±ºæˆ¦", area: "ãƒŸãƒƒãƒ‰ã‚¦ã‚§ãƒ¼è¿‘æµ·", mission: "æ•µæˆ¦è‰¦ã‚’æ’ƒæ²ˆã›ã‚ˆ" },
			{ name: "è¿½æ’ƒ", area: "å¤ªå¹³æ´‹ä¸­éƒ¨", mission: "æ•µç©ºæ¯ã‚’æ’ƒæ²ˆã›ã‚ˆ" },
			{ name: "é‚€æ’ƒ", area: "æ•µç·¨éšŠç©ºåŸŸ", mission: "æ•µèˆªç©ºéšŠã‚’æ®²æ»…ã›ã‚ˆ" },
			{ name: "æ­»é—˜", area: "æ—¥æœ¬è¿‘æµ·", mission: "æ•µèˆªç©ºæˆ¦è‰¦ã‚’æ’ƒæ²ˆã›ã‚ˆ" },
			{ name: "æ¿€æˆ¦", area: "æ±ã‚·ãƒŠæµ·", mission: "æ•µç©ºæ¯ã‚’æ’ƒæ²ˆã›ã‚ˆ" },
			{ name: "åæ’ƒ", area: "æ•µè¦å¡ä¸Šç©º", mission: "æ•µçˆ†æ’ƒæ©Ÿã‚’æ’ƒå¢œã›ã‚ˆ" },
			{ name: "çªç ´", area: "ç€¬æˆ¸å†…æµ·", mission: "æ•µæˆ¦è‰¦ã‚’æ’ƒæ²ˆã›ã‚ˆ" },
			{ name: "æ®²æ»…", area: "æ•µæœ¬æ‹ åœ°ä¸Šç©º", mission: "æ•µèˆªç©ºéšŠã‚’æ®²æ»…ã›ã‚ˆ" },
			{ name: "çŒ›æ”»", area: "å‘‰è»æ¸¯æ²–", mission: "æ•µæˆ¦è‰¦ã‚’æ’ƒæ²ˆã›ã‚ˆ" },
			{ name: "ç·æ”»æ’ƒ", area: "æ•µæœ€çµ‚é˜²è¡›ç·š", mission: "æ•µç©ºæ¯ã‚’æ’ƒæ²ˆã›ã‚ˆ" },
			{ name: "æ±ºæ­»", area: "æ•µæ——è‰¦ä¸Šç©º", mission: "æ•µçˆ†æ’ƒæ©Ÿã‚’æ’ƒå¢œã›ã‚ˆ" },
			{ name: "æœ€çµ‚æ±ºæˆ¦", area: "æ•µå¸ä»¤éƒ¨æ²–", mission: "æ•µæˆ¦è‰¦ã‚’æ’ƒæ²ˆã›ã‚ˆ" },
			{ name: "çµ‚ç„‰", area: "å¤§å’Œæ²–", mission: "æ•µæ——è‰¦å¤§å’Œã‚’æ’ƒæ²ˆã›ã‚ˆ" },
		];

		// --- Keyboard Input ---
		const keys = { up: false, down: false, left: false, right: false };

		// Player State
		const player = {
			x: 0, y: 0, w: 40, h: 46,
			lives: 3,
			fuel: MAX_FUEL,
			invincible: 0,
			weapons: [{ type: 'NORMAL', lv: 1 }],
			sideFighters: 0,
		};

		let bullets = [];
		let enemies = [];
		let particles = [];
		let powerups = [];
		let floatingTexts = []; // [{x, y, text, color, life, vy}]

		// Input
		let targetX = null, targetY = null;
		window.addEventListener('mousemove', e => { targetX = e.clientX; targetY = e.clientY; });
		window.addEventListener('touchmove', e => { e.preventDefault(); targetX = e.touches[0].clientX; targetY = e.touches[0].clientY; }, { passive: false });
		window.addEventListener('resize', resize);
		window.addEventListener('keydown', e => {
			switch (e.code) {
				case 'KeyW': case 'ArrowUp': keys.up = true; break;
				case 'KeyS': case 'ArrowDown': keys.down = true; break;
				case 'KeyA': case 'ArrowLeft': keys.left = true; break;
				case 'KeyD': case 'ArrowRight': keys.right = true; break;
				case 'Space': case 'KeyZ': triggerSpecial(); break;
				case 'Escape': case 'KeyP': togglePause(); break;
			}
			if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
				e.preventDefault();
			}
		});
		window.addEventListener('keyup', e => {
			switch (e.code) {
				case 'KeyW': case 'ArrowUp': keys.up = false; break;
				case 'KeyS': case 'ArrowDown': keys.down = false; break;
				case 'KeyA': case 'ArrowLeft': keys.left = false; break;
				case 'KeyD': case 'ArrowRight': keys.right = false; break;
			}
		});

		function resize() {
			width = canvas.width = window.innerWidth;
			height = canvas.height = window.innerHeight;
			if (!gameRunning) { player.x = width / 2; player.y = height - 100; targetX = width / 2; targetY = height - 100; }
			document.getElementById('hiscore').innerText = hiscore;
		}

		function triggerSpecial(e) {
			if (e) e.stopPropagation();
			if (!gameRunning || player.fuel < 15) return;

			SFX.special();
			player.fuel -= 15;
			shake = 20;

			// Random Special Effect
			const r = Math.random();
			let type = "LIGHTNING";
			let color = "#ffff00";
			if (r > 0.4) type = "TSUNAMI";
			if (r > 0.7) type = "CYCLONE";

			const overlay = document.getElementById('mega-crash-overlay');
			overlay.style.opacity = 0.8;
			setTimeout(() => overlay.style.opacity = 0, 800);

			if (type === 'LIGHTNING') {
				showCenterMsg("âš¡ LIGHTNING âš¡");
				for (let i = 0; i < 10; i++) spawnParticles(Math.random() * width, Math.random() * height, '#ffff00', 5);
				enemies.forEach((e, i) => {
					if (e.type !== 'boss') { e.hp = 0; spawnParticles(e.x, e.y, color, 10); }
					else { e.hp -= 50; }
				});
			} else if (type === 'TSUNAMI') {
				showCenterMsg("ğŸŒŠ TSUNAMI ğŸŒŠ");
				enemies.forEach((e, i) => {
					if (e.type !== 'boss') { e.hp = 0; spawnParticles(e.x, e.y, '#00ffff', 10); }
					else { e.hp -= 30; }
				});
				bullets = [];
			} else if (type === 'CYCLONE') {
				showCenterMsg("ğŸŒ€ CYCLONE ğŸŒ€");
				bullets = [];
				enemies.forEach(e => { if (e.type !== 'boss') e.hp -= 10; });
			}
		}

		function toggleSound() {
			const enabled = SFX.toggle();
			document.getElementById('sound-btn').textContent = enabled ? 'ğŸ”Š' : 'ğŸ”‡';
		}

		function togglePause() {
			if (!gameRunning) return;
			paused = !paused;
		}

		// Difficulty selection handlers
		const DIFFICULTY_DESCRIPTIONS = {
			easy:   'æ–°æ‰‹å‹å–„ï¼Œæ•µäººè¼ƒå¼±ï¼Œå¤šæ¢å‘½è®“ä½ ç†Ÿæ‚‰éŠæˆ²',
			normal: 'æ¨™æº–é›£åº¦ï¼Œé©åˆå¤§å¤šæ•¸ç©å®¶',
			hard:   'æ•µäººæ›´å¼·æ›´å¿«ï¼Œè€ƒé©—ä½ çš„æŠ€è¡“',
			arcade: 'è¡—æ©ŸåŸå§‹é›£åº¦ï¼Œä¸€å‘½é€šé—œï¼çœŸæ­£çš„æŒ‘æˆ°',
		};

		function selectDifficulty(diff) {
			currentDifficulty = diff;
			const preset = DIFFICULTY_PRESETS[diff];
			difficultyMult = preset.hpMult;
			bulletSpeedMult = preset.bulletMult;
			startingLives = preset.lives;

			// Update UI
			document.querySelectorAll('.diff-btn').forEach(btn => {
				btn.classList.remove('selected');
				if (btn.dataset.diff === diff) {
					btn.classList.add('selected');
				}
			});
			document.getElementById('difficulty-desc').textContent = DIFFICULTY_DESCRIPTIONS[diff];
		}

		// Initialize difficulty buttons
		document.addEventListener('DOMContentLoaded', () => {
			document.querySelectorAll('.diff-btn').forEach(btn => {
				btn.addEventListener('click', () => selectDifficulty(btn.dataset.diff));
			});
		});

		function startGame() {
			SFX.init();
			SFX.missionStart();

			// Apply difficulty settings
			const preset = DIFFICULTY_PRESETS[currentDifficulty];
			difficultyMult = preset.hpMult;
			bulletSpeedMult = preset.bulletMult;
			startingLives = preset.lives;
			paused = false;

			document.getElementById('start-screen').classList.add('hidden');
			document.getElementById('end-screen').classList.add('hidden');
			document.getElementById('win-screen').classList.add('hidden');
			document.getElementById('boss-ui').style.display = 'none';

			// Update difficulty display in HUD
			const diffDisplay = document.getElementById('difficulty-display');
			diffDisplay.textContent = preset.name;
			diffDisplay.style.color = preset.color;

			player.lives = startingLives;
			player.fuel = MAX_FUEL;
			player.weapons = [{ type: 'AUTO', lv: 1 }];
			player.sideFighters = 0;
			player.invincible = 0;
			score = 0;
			combo = 0;
			comboTimer = 0;
			maxCombo = 0;
			bossWarning = false;
			bossWarningTimer = 0;
			bossWarningData = null;
			stageTransition = false;
			stageTransitionTimer = 0;
			stage = 1;
			nextBossTrigger = 4000;
			frame = 0;
			bossActive = false;
			bgScrollSpeed = 3;
			shake = 0;

			enemies = []; bullets = []; particles = []; powerups = []; floatingTexts = [];

			// Show stage 1 intro
			stageTransition = true;
			stageTransitionTimer = STAGE_TRANSITION_DURATION;
			SFX.missionStart();

			resize();
			gameRunning = true;
			loop();
		}

		// --- Core Update ---
		function update() {
			frame++;
			bgOffset += bgScrollSpeed;
			if (shake > 0) shake *= 0.9;
			if (Math.abs(shake) < 0.5) shake = 0;

			// Combo timer decay
			if (comboTimer > 0) {
				comboTimer--;
				if (comboTimer === 0) {
					combo = 0; // Reset combo when timer expires
				}
			}

			// Boss warning timer
			if (bossWarning && bossWarningTimer > 0) {
				bossWarningTimer--;
				// Play warning beep periodically
				if (bossWarningTimer % 30 === 0 && bossWarningTimer > 0) {
					SFX.warning();
				}
				if (bossWarningTimer === 0) {
					actuallySpawnBoss();
				}
				return; // Skip normal update during warning
			}

			// Stage transition timer
			if (stageTransition && stageTransitionTimer > 0) {
				stageTransitionTimer--;
				if (stageTransitionTimer === 0) {
					stageTransition = false;
					nextBossTrigger = score + 5000 + (stage * 3000);
					// Play a ready sound
					SFX.powerup();
				}
				return; // Skip normal update during transition
			}

			// Player logic - Keyboard has priority
			if (keys.up || keys.down || keys.left || keys.right) {
				if (keys.up) player.y -= KEY_SPEED;
				if (keys.down) player.y += KEY_SPEED;
				if (keys.left) player.x -= KEY_SPEED;
				if (keys.right) player.x += KEY_SPEED;
			} else if (targetX !== null) {
				player.x += (targetX - player.x) * PLAYER_SPEED;
				player.y += (targetY - player.y) * PLAYER_SPEED;
			}
			player.x = Math.max(20, Math.min(width - 20, player.x));
			player.y = Math.max(20, Math.min(height - 20, player.y));
			if (player.invincible > 0) player.invincible--;

			if (frame % 45 === 0 && player.fuel < MAX_FUEL) player.fuel = Math.min(MAX_FUEL, player.fuel + 1);

			// Player Fire
			if (frame % 7 === 0) firePlayer();

			// Enemy Spawning
			if (!bossActive) {
				// Ground Turrets
				if (frame % 150 === 0 && Math.random() < 0.5) spawnTurret();

				// Mini Boss
				if (frame % 400 === 0 && Math.random() < 0.3) spawnMiniBoss();

				// Red Formation - fixed every 30 seconds (1800 frames)
				if (frame % 1800 === 0 && frame > 0) {
					spawnRedFormation();
				}

				if (score > nextBossTrigger) {
					spawnBoss();
				} else if (enemies.length < 6 + stage) {
					// Dynamic spawn interval: slower in later stages
					// Stage 1-4: 35 frames, Stage 5-8: 40, Stage 9-12: 45, Stage 13-16: 50
					const spawnInterval = 35 + Math.floor((stage - 1) / 4) * 5;
					if (frame % spawnInterval === 0) spawnEnemy();
				}
			}

			updateEntities();

			// HUD
			document.getElementById('score').innerText = score;
			document.getElementById('lives-display').innerText = "â¤".repeat(Math.max(0, player.lives));
			document.getElementById('stage-display').innerText = stage;
			document.getElementById('fuel-bar-fill').style.width = (player.fuel / MAX_FUEL * 100) + '%';

			// Weapon Badges
			let wHtml = '';
			player.weapons.forEach(w => {
				let color = WEAPONS[w.type].color;
				let badge = w.type === 'NORMAL' ? 'N' : w.type.charAt(0);
				if (w.type === 'SHOTGUN') badge = 'S';
				if (w.type === '3WAY') badge = '3';
				if (w.type === 'AUTO') badge = 'A';
				if (w.type === 'SHELL') badge = 'M';
				if (w.type === 'LASER') badge = 'L';

				let style = `background:${color}; color:${w.type === 'AUTO' || w.type === '3WAY' ? 'black' : 'white'}`;
				wHtml += `<div class="weapon-badge" style="${style}">${badge}${w.lv}</div>`;
			});
			document.getElementById('active-weapons').innerHTML = wHtml;
		}

		function firePlayer() {
			let hasLaser = false, hasShell = false;
			player.weapons.forEach((w, idx) => {
				const type = w.type;
				const lv = w.lv;
				if (type === 'LASER') hasLaser = true;
				if (type === 'SHELL') hasShell = true;

				if (type === 'SHOTGUN') {
					const count = 3 + lv * 2;
					const spread = 0.5 + (lv * 0.1);
					for (let i = 0; i < count; i++) {
						const angle = -spread / 2 + (spread / (count - 1)) * i;
						bullets.push({
							x: player.x, y: player.y - 10,
							vx: Math.sin(angle) * 15, vy: -Math.cos(angle) * 15,
							w: 8 + (lv * 2), h: 8 + (lv * 2), color: '#00ff00',
							owner: 'player', type: 'shotgun', dmg: 2 + lv, life: 30 + lv * 10
						});
					}
				}
				else if (type === '3WAY') {
					const spd = 12 + lv * 2;
					bullets.push({ x: player.x, y: player.y, vx: 0, vy: -spd, w: 8, h: 16, color: '#ffff00', owner: 'player', dmg: 2 + lv });
					bullets.push({ x: player.x, y: player.y, vx: -5, vy: -spd * 0.9, w: 8, h: 16, color: '#ffff00', owner: 'player', dmg: 2 + lv });
					bullets.push({ x: player.x, y: player.y, vx: 5, vy: -spd * 0.9, w: 8, h: 16, color: '#ffff00', owner: 'player', dmg: 2 + lv });
					if (lv >= 3) {
						bullets.push({ x: player.x, y: player.y, vx: -3, vy: spd * 0.5, w: 8, h: 8, color: '#ffff00', owner: 'player', dmg: 2 });
						bullets.push({ x: player.x, y: player.y, vx: 3, vy: spd * 0.5, w: 8, h: 8, color: '#ffff00', owner: 'player', dmg: 2 });
					}
				}
				else if (type === 'AUTO') {
					const offX = (idx % 2 === 0) ? -5 : 5;
					const spd = 18;
					bullets.push({ x: player.x + offX, y: player.y - 20, vx: 0, vy: -spd, w: 6, h: 20, color: '#fff', owner: 'player', dmg: 1 + lv });
					if (lv >= 2) bullets.push({ x: player.x - offX, y: player.y - 20, vx: 0, vy: -spd, w: 6, h: 20, color: '#fff', owner: 'player', dmg: 1 + lv });
				}
				else if (type === 'SHELL') {
					const spd = 10;
					bullets.push({ x: player.x, y: player.y - 20, vx: 0, vy: -spd, w: 15 + (lv * 5), h: 25 + (lv * 5), color: '#ff5500', owner: 'player', type: 'shell', dmg: 10 + lv * 10 });
				}
				else if (type === 'LASER') {
					const spd = 25;
					const wL = 8 + lv * 4;
					bullets.push({ x: player.x, y: player.y - 30, vx: 0, vy: -spd, w: wL, h: 60, color: '#00ccff', owner: 'player', type: 'laser', dmg: 3 + lv * 2 });
				}
				else {
					bullets.push({ x: player.x, y: player.y - 20, vx: 0, vy: -15, w: 6, h: 14, color: '#fff', owner: 'player', dmg: 1 });
				}
			});

			if (player.sideFighters > 0) bullets.push({ x: player.x - 40, y: player.y, vx: 0, vy: -15, w: 4, h: 10, color: '#fff', owner: 'player' });
			if (player.sideFighters > 1) bullets.push({ x: player.x + 40, y: player.y, vx: 0, vy: -15, w: 4, h: 10, color: '#fff', owner: 'player' });

			// éŸ³æ•ˆ
			if (hasShell) SFX.shell();
			else if (hasLaser) SFX.laser();
			else SFX.shoot();
		}

		// Movement pattern types
		const MOVE_PATTERNS = {
			STRAIGHT: 0,      // ç›´ç·šå‘ä¸‹
			SINE_WAVE: 1,     // æ­£å¼¦æ³¢å·¦å³æ–æ“º
			DIVE_ATTACK: 2,   // ä¿¯è¡æ”»æ“Šï¼ˆè¡å‘ç©å®¶ï¼‰
			LOOP: 3,          // è¿´æ—‹
			ZIGZAG: 4,        // Zå­—å½¢ç§»å‹•
			SWOOP: 5,         // å¼§å½¢ä¿¯è¡å¾Œé£›é›¢
		};

		// Spawn a formation of 5 red enemies (fixed every 30 seconds)
		function spawnRedFormation() {
			const formationX = Math.random() * (width - 200) + 100;
			const positions = [
				{ x: 0, y: 0 },      // Leader
				{ x: -40, y: 40 },   // Left wing
				{ x: 40, y: 40 },    // Right wing
				{ x: -80, y: 80 },   // Far left
				{ x: 80, y: 80 },    // Far right
			];

			positions.forEach((pos, i) => {
				const x = formationX + pos.x;
				const e = {
					x, y: -50 - pos.y, hp: Math.ceil(3 * difficultyMult),
					w: 40, h: 40, type: 'red_formation',
					spawnFrame: frame,
					startX: x,
					baseVy: 4,
					vy: 4,
					vx: 0,
					color: '#ff0000',
					isRed: true,
					movePattern: MOVE_PATTERNS.LOOP,
					loopRadius: 50 + i * 10,
					loopSpeed: 0.04,
				};
				enemies.push(e);
			});

			showCenterMsg("RED FORMATION!");
		}

		function spawnEnemy() {
			const r = Math.random();
			let type = 'green';
			if (stage > 2 && r < 0.3) type = 'grey';

			const x = Math.random() * (width - 40) + 20;
			let e = {
				x, y: -50, hp: 1, w: 40, h: 40, type,
				spawnFrame: frame,  // è¨˜éŒ„ç”Ÿæˆæ™‚çš„å¹€æ•¸
				startX: x,          // è¨˜éŒ„èµ·å§‹ X ä½ç½®
				movePattern: MOVE_PATTERNS.STRAIGHT,
				patternPhase: 0,
			};

			// æ ¹æ“šé¡å‹è¨­å®šå±¬æ€§å’Œç§»å‹•æ¨¡å¼
			if (type === 'green') {
				e.hp = Math.ceil((2 + stage) * difficultyMult);
				e.baseVy = 3 + (stage * 0.15);
				e.vy = e.baseVy;
				e.vx = 0;

				// éš¨æ©Ÿé¸æ“‡ç§»å‹•æ¨¡å¼
				const patternRoll = Math.random();
				if (patternRoll < 0.3) {
					e.movePattern = MOVE_PATTERNS.SINE_WAVE;
					e.waveAmp = 40 + Math.random() * 40;   // æŒ¯å¹… 40-80
					e.waveFreq = 0.03 + Math.random() * 0.03; // é »ç‡
				} else if (patternRoll < 0.5) {
					e.movePattern = MOVE_PATTERNS.ZIGZAG;
					e.zigzagDir = Math.random() < 0.5 ? 1 : -1;
					e.zigzagTimer = 0;
				} else if (patternRoll < 0.65 && stage > 3) {
					e.movePattern = MOVE_PATTERNS.DIVE_ATTACK;
					e.divePhase = 0;
					e.diveTarget = { x: 0, y: 0 };
				} else if (patternRoll < 0.75 && stage > 5) {
					e.movePattern = MOVE_PATTERNS.SWOOP;
					e.swoopPhase = 0;
					e.swoopDir = Math.random() < 0.5 ? 1 : -1;
				}
			}

			if (type === 'grey') {
				e.hp = Math.ceil((8 + stage * 2) * difficultyMult);
				e.baseVy = 2;
				e.vy = e.baseVy;
				e.vx = 0;
				e.w = 60;
				e.h = 50;
				// ç°è‰²å¤§å‹æ©Ÿä½¿ç”¨æ­£å¼¦æ³¢
				e.movePattern = MOVE_PATTERNS.SINE_WAVE;
				e.waveAmp = 30;
				e.waveFreq = 0.02;
			}

			enemies.push(e);
		}

		function spawnMiniBoss() {
			const x = Math.random() * (width - 100) + 50;
			enemies.push({
				x, y: -80, w: 100, h: 80, hp: Math.ceil((100 + stage * 20) * difficultyMult), type: 'miniboss', vy: 1, phase: 0
			});
			showCenterMsg("âš  ALERT âš ");
		}

		function spawnTurret() {
			// Ground unit, moves with BG speed
			const x = Math.random() * (width - 60) + 30;
			enemies.push({
				x, y: -50, w: 50, h: 50, hp: Math.ceil((30 + stage * 5) * difficultyMult), type: 'turret', vy: bgScrollSpeed, phase: 0,
				angle: 0
			});
		}

		function spawnBoss() {
			if (stage > BOSS_DATA.length) {
				gameRunning = false;
				document.getElementById('win-screen').classList.remove('hidden');
				document.getElementById('final-win-score').innerText = score;
				document.getElementById('final-win-combo').innerText = maxCombo;

				// Show difficulty on win screen
				const preset = DIFFICULTY_PRESETS[currentDifficulty];
				const winDiff = document.getElementById('win-difficulty');
				winDiff.textContent = preset.name;
				winDiff.style.color = preset.color;
				return;
			}

			const data = BOSS_DATA[stage - 1];

			// Start warning sequence
			bossWarning = true;
			bossWarningTimer = BOSS_WARNING_DURATION;
			bossWarningData = data;

			// Play warning sound
			SFX.warning();
			shake = 10;

			// Clear existing enemies during warning
			enemies = enemies.filter(e => e.type === 'boss');
			bullets = [];
		}

		function actuallySpawnBoss() {
			if (!bossWarningData) return;

			const data = bossWarningData;
			bossActive = true;
			document.getElementById('boss-ui').style.display = 'block';
			document.getElementById('boss-name').innerText = data.name;
			document.getElementById('boss-sub').innerText = data.type;
			updateBossBar(100);

			// Spawn Position logic
			let startY = -data.h - 50;
			let startVy = 1;
			if (data.enter === 'bottom') {
				startY = height + data.h + 50;
				startVy = -1;
			}

			const bossHp = Math.ceil(data.hp * difficultyMult);
			const boss = {
				x: width / 2, y: startY, w: data.w, h: data.h,
				hp: bossHp, maxHp: bossHp,
				type: 'boss', subType: data.type, enter: data.enter || 'top', phase: 0,
				vx: 0, vy: startVy,
				parts: data.parts ? JSON.parse(JSON.stringify(data.parts)) : [] // Deep copy parts
			};
			// Initial aim for turrets
			boss.parts.forEach(p => { p.currCd = Math.random() * p.cd; p.angle = 0; });
			enemies.push(boss);

			// Clear warning state
			bossWarning = false;
			bossWarningData = null;
		}

		function updateEntities() {
			// Powerups
			for (let i = powerups.length - 1; i >= 0; i--) {
				const p = powerups[i];
				p.y += 2;
				if (frame % 30 < 15) { p.scale = 1.1; } else { p.scale = 1.0; }

				if (Math.hypot(p.x - player.x, p.y - player.y) < 40) {
					let wKey = null;
					if (p.type === 'S') wKey = 'SHOTGUN';
					if (p.type === '3') wKey = '3WAY';
					if (p.type === 'A') wKey = 'AUTO';
					if (p.type === 'M') wKey = 'SHELL';
					if (p.type === 'L') wKey = 'LASER';

					let msg = "";
					let isUpgrade = false;
					if (wKey) {
						const existing = player.weapons.find(w => w.type === wKey);
						if (existing) {
							if (existing.lv < 3) {
								existing.lv++;
								msg = wKey + " UP L" + existing.lv;
								isUpgrade = true;
							} else {
								msg = "MAX POWER";
								score += 2000;
								isUpgrade = true;
							}
						} else {
							if (player.weapons.length < 3) {
								player.weapons.push({ type: wKey, lv: 1 });
								msg = "GET " + wKey;
							} else {
								player.weapons.shift();
								player.weapons.push({ type: wKey, lv: 1 });
								msg = "EQUIP " + wKey;
							}
						}
						player.fuel = Math.min(MAX_FUEL, player.fuel + 20);
					}

					if (p.type === 'side') {
						player.sideFighters = Math.min(2, player.sideFighters + 1);
						score += 1000;
						msg = "SIDE FIGHTER";
					}
					if (p.type === '1UP') {
						player.lives++;
						score += 5000;
						msg = "1UP!";
						isUpgrade = true;
					}

					// éŸ³æ•ˆ
					if (isUpgrade) SFX.upgrade();
					else if (msg) SFX.powerup();

					if (msg) spawnFloatingText(player.x, player.y - 30, msg, '#fff');

					powerups.splice(i, 1);
				} else if (p.y > height) powerups.splice(i, 1);
			}

			// Enemies
			for (let i = enemies.length - 1; i >= 0; i--) {
				const e = enemies[i];

				if (e.type === 'boss') {
					// === HP-based Phase System ===
					const hpPct = e.hp / e.maxHp;
					const aggroPhase = hpPct < 0.3 ? 3 : (hpPct < 0.7 ? 2 : 1);
					const moveSpeed = [1, 1, 1.2, 1.5][aggroPhase];
					const fireRateMult = [1, 1, 0.75, 0.5][aggroPhase];
					const isBattleship = e.subType.includes("Battleship") || e.subType.includes("Flagship");
					// Movement State Machine
					let targetY = 150;
					if (e.enter === 'bottom') targetY = height - 380; // Higher position for mobile players

					// Approach Phase
					if (e.phase === 0) {
						if (Math.abs(e.y - targetY) > 5) {
							e.y += (targetY - e.y) * 0.008 * moveSpeed;
						} else {
							e.phase = 1; e.movePattern = 0;
							e.tick = 0;
						}
					}
					// Battle Patterns (Vertical Sweep for Bottom Bosses)
					else {
						e.tick = (e.tick || 0) + 1;

						if (e.enter === 'bottom') {
							// Vertical Sweep: Cycle 1200 frames
							const cycle = e.tick % 1200;
							if (cycle < 300) e.y -= 0.4 * moveSpeed;      // Advance (Up)
							else if (cycle < 600);            // Wait
							else if (cycle < 700) e.y += 0.35 * moveSpeed;// Retreat (Down)
							else;                             // Wait

							e.x += (player.x - e.x) * 0.015 * moveSpeed;
						} else {
							// Top bosses: Multiple movement patterns
							if (e.tick % 600 === 0) e.movePattern = (e.movePattern + 1) % 4;
							switch (e.movePattern || 0) {
								case 0:
									e.x = (width / 2) + Math.sin(e.tick * 0.008) * 70 * moveSpeed;
									e.y = targetY + Math.sin(e.tick * 0.015) * 25;
									break;
								case 1:
									e.x += (player.x - e.x) * 0.02 * moveSpeed;
									e.y = targetY + Math.sin(e.tick * 0.02) * 15;
									break;
								case 2:
									e.x = (width / 2) + Math.sin(e.tick * 0.01) * 70;
									e.y = targetY + Math.sin(e.tick * 0.02) * 35;
									break;
								case 3:
									if (isBattleship && aggroPhase >= 2) {
										const dp = e.tick % 400;
										if (dp < 150) e.y += 0.5 * moveSpeed;
										else if (dp < 250) e.y -= 0.4 * moveSpeed;
									}
									e.x = (width / 2) + Math.sin(e.tick * 0.012) * 50;
									break;
							}
						}
						e.x = Math.max(e.w/2+10, Math.min(width-e.w/2-10, e.x));
						e.y = Math.max(80, Math.min(e.enter=="top" ? height*0.45 : height-80, e.y));
					}

					// Boss Attack Logic
					// Boss Attack Logic (Turrets)
					const isCarrier = e.subType.includes("Carrier");

					// Update Parts
					if (e.parts) {
						e.parts.forEach(p => {
							if (p.t === 'turret_main' || p.t === 'turret_aa') {
								// Rotate towards player
								// Compensate boss rotation if any (none yet)
								let angleToPlayer = Math.atan2(player.y - (e.y + p.y), player.x - (e.x + p.x));
								if (e.enter === 'bottom') {
									// If chasing from bottom, y axis is flipped relative to "front" logic?
									// Actually Math.atan2 works in world space, so it's fine.
									// Just visual rotation needs care.
								}
								// Simple lerp rotation?
								p.angle = angleToPlayer;

								if (p.currCd > 0) p.currCd--;
								else {
									p.currCd = Math.floor(p.cd * fireRateMult);
									if (p.t === 'turret_main') {
										const spd = 6;
										fireBullet(e.x + p.x, e.y + p.y, Math.cos(p.angle) * spd, Math.sin(p.angle) * spd, '#ff0055');
										if (aggroPhase >= 2) {
											fireBullet(e.x + p.x, e.y + p.y, Math.cos(p.angle + 0.1) * spd, Math.sin(p.angle + 0.1) * spd, '#ff0055');
											fireBullet(e.x + p.x, e.y + p.y, Math.cos(p.angle - 0.1) * spd, Math.sin(p.angle - 0.1) * spd, '#ff0055');
										}
									} else {
										const spd = 5;
										const bulletCount = aggroPhase === 3 ? 5 : 3;
										for (let bi = 0; bi < bulletCount; bi++) {
											const angle = p.angle + (bi - (bulletCount-1)/2) * 0.25;
											fireBullet(e.x + p.x, e.y + p.y, Math.cos(angle) * spd, Math.sin(angle) * spd, '#ffaa00');
										}
									}
								}
							} else if (p.t === 'propeller') {
								p.angle = (p.angle || 0) + (p.spd || 0.5);
							}
						});
					}

					// Carrier: Launch plane formations
					if (isCarrier && e.phase > 0) {
						const launchInterval = aggroPhase === 3 ? 90 : (aggroPhase === 2 ? 150 : 240);
						if (frame % launchInterval === 0) {
							const planeCount = aggroPhase >= 2 ? 5 : 3;
							const offsets = [{dx:0,dy:0},{dx:-35,dy:35},{dx:35,dy:35},{dx:-70,dy:70},{dx:70,dy:70}];
							for (let pi = 0; pi < planeCount; pi++) {
								const off = offsets[pi];
								enemies.push({
									x: e.x + off.dx, y: e.y + off.dy + 50,
									hp: Math.ceil(3 * difficultyMult), w: 25, h: 25,
									type: 'green', spawnFrame: frame, startX: e.x + off.dx,
									movePattern: 1, waveAmp: 25, waveFreq: 0.04, vy: 3, vx: 0
								});
							}
						}
					}

					// Special attack at critical HP (circular burst)
					if (aggroPhase === 3 && e.tick % 360 === 0) {
						const burstCount = 12 + Math.floor(stage / 2);
						for (let bi = 0; bi < burstCount; bi++) {
							const angle = (Math.PI * 2 / burstCount) * bi;
							fireBullet(e.x, e.y, Math.cos(angle) * 3.5, Math.sin(angle) * 3.5, '#ff00ff');
						}
						shake = 5;
					}

					updateBossBar(Math.max(0, hpPct * 100));

				} else if (e.type === 'turret') {
					e.y += e.vy;
					// Turret logic: Interval Continuous Fire (Burst), "Won't Move" (Static Visual)
					if (e.y > 0 && e.y < height) {
						if (!e.burst) e.burst = 0;
						// Trigger burst every few seconds
						if (frame % 200 === 0) {
							e.burst = 3; // Queue 3 shots
						}

						if (e.burst > 0 && frame % 10 === 0) {
							e.burst--;
							// Aim at player for bullet velocity, but visual angle static?
							const angle = Math.atan2(player.y - e.y, player.x - e.x);
							// Do NOT update e.angle if we want it static visually
							e.angle = Math.PI / 2; // Point down visually
							fireBullet(e.x, e.y, Math.cos(angle) * 4, Math.sin(angle) * 4, '#ffaa00');
						}
					}
				} else if (e.type === 'miniboss') {
					if (e.y < 100) e.y += 0.5; // Slower entry
					else {
						e.x += Math.cos(frame * 0.02) * 2; // Slower horizontal sway
						if (frame % 150 === 0) { // Much slower fire rate (was 50)
							// [TUNING] Early stages: Downward spread only. Later: Spin.
							if (stage <= 3) {
								for (let a = Math.PI * 0.25; a <= Math.PI * 0.75; a += 0.15) {
									// Slower bullets (spd 3 instead of 4)
									fireBullet(e.x, e.y, Math.cos(a) * 3, Math.sin(a) * 3, '#ffaa00');
								}
							} else {
								for (let a = 0; a < Math.PI * 2; a += 0.6) fireBullet(e.x, e.y, Math.cos(a) * 3, Math.sin(a) * 3, '#ffaa00');
							}
						}
					}
				} else {
					// æ ¹æ“šç§»å‹•æ¨¡å¼æ›´æ–°ä½ç½®
					const age = frame - (e.spawnFrame || 0);

					switch (e.movePattern) {
						case MOVE_PATTERNS.SINE_WAVE:
							// æ­£å¼¦æ³¢ï¼šåŸºæ–¼èµ·å§‹ä½ç½®å·¦å³æ“ºå‹•
							e.x = e.startX + Math.sin(age * e.waveFreq) * e.waveAmp;
							e.y += e.vy;
							break;

						case MOVE_PATTERNS.ZIGZAG:
							// Zå­—å½¢ï¼šå®šæ™‚æ”¹è®Šæ–¹å‘
							e.zigzagTimer = (e.zigzagTimer || 0) + 1;
							if (e.zigzagTimer > 40) {
								e.zigzagDir *= -1;
								e.zigzagTimer = 0;
							}
							e.x += e.zigzagDir * 3;
							e.y += e.vy;
							// é‚Šç•Œåå½ˆ
							if (e.x < 30 || e.x > width - 30) e.zigzagDir *= -1;
							break;

						case MOVE_PATTERNS.DIVE_ATTACK:
							// ä¿¯è¡æ”»æ“Šï¼šå…ˆä¸‹é™ï¼Œåˆ°ä¸€å®šé«˜åº¦å¾Œè¡å‘ç©å®¶
							if (e.divePhase === 0) {
								// éšæ®µ0ï¼šç·©æ…¢ä¸‹é™
								e.y += e.vy * 0.5;
								if (e.y > height * 0.2) {
									e.divePhase = 1;
									e.diveTarget.x = player.x;
									e.diveTarget.y = player.y;
								}
							} else if (e.divePhase === 1) {
								// éšæ®µ1ï¼šè¡å‘ç©å®¶ä½ç½®
								const dx = e.diveTarget.x - e.x;
								const dy = e.diveTarget.y - e.y;
								const dist = Math.hypot(dx, dy);
								if (dist > 10) {
									e.x += (dx / dist) * 8;
									e.y += (dy / dist) * 8;
								} else {
									e.divePhase = 2;
								}
							} else {
								// éšæ®µ2ï¼šç¹¼çºŒå‘ä¸‹é£›é›¢
								e.y += e.vy * 1.5;
							}
							break;

						case MOVE_PATTERNS.LOOP:
							// è¿´æ—‹ï¼šèºæ—‹å½¢ä¸‹é™
							const loopAngle = age * e.loopSpeed;
							e.x = e.startX + Math.cos(loopAngle) * e.loopRadius;
							e.y += e.vy + Math.sin(loopAngle) * 1.5;
							break;

						case MOVE_PATTERNS.SWOOP:
							// å¼§å½¢ä¿¯è¡ï¼šå…ˆå‘ä¸€å´å¼§å½¢ä¿¯è¡ï¼Œç„¶å¾Œé£›é›¢
							if (e.swoopPhase === 0) {
								// å¼§å½¢ä¿¯è¡
								e.x += e.swoopDir * 4;
								e.y += e.vy + Math.abs(Math.sin(age * 0.05)) * 3;
								if (e.y > height * 0.6) e.swoopPhase = 1;
							} else {
								// åå‘é£›é›¢
								e.x -= e.swoopDir * 3;
								e.y += e.vy * 0.5;
							}
							break;

						default:
							// ç›´ç·šï¼šæ™®é€šç§»å‹•
							e.x += e.vx;
							e.y += e.vy;
					}

					// ç°è‰²æ•µæ©Ÿå°„æ“Š
					if (e.type === 'grey' && frame % 80 === 0 && e.y > 0 && e.y < height) {
						fireBullet(e.x, e.y + 20, 0, 4, '#ffaa00');
					}

					// ä¿¯è¡æ”»æ“Šæ™‚ç™¼å°„å­å½ˆ
					if (e.movePattern === MOVE_PATTERNS.DIVE_ATTACK && e.divePhase === 1 && frame % 20 === 0) {
						const angle = Math.atan2(player.y - e.y, player.x - e.x);
						fireBullet(e.x, e.y, Math.cos(angle) * 5, Math.sin(angle) * 5, '#ff6600');
					}
				}

				// Collision Player
				if (player.invincible <= 0 && Math.abs(player.x - e.x) < (e.w + 20) / 2 && Math.abs(player.y - e.y) < (e.h + 20) / 2) {
					// Ground units only collide if "flying low"? 1943 usually invincible to collision with ground unless crashing.
					// But bullets hit. Let's make ground unit collision safe (fly over).
					if (e.type !== 'turret') playerHit();
				}

				if (e.y > height + 800) enemies.splice(i, 1);
			}

			// Bullets
			for (let i = bullets.length - 1; i >= 0; i--) {
				const b = bullets[i];
				if (!b) continue; // Safety

				b.x += b.vx; b.y += b.vy;
				if (b.life) {
					b.life--;
					if (b.life <= 0) { bullets.splice(i, 1); continue; }
				}

				if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {
					bullets.splice(i, 1);
					continue;
				}

				if (b.owner === 'player') {
					for (let j = enemies.length - 1; j >= 0; j--) {
						const e = enemies[j];
						if (Math.abs(b.x - e.x) < e.w / 2 && Math.abs(b.y - e.y) < e.h / 2) {
							e.hp -= (b.dmg || 1);

							if (!b.type || b.type !== 'laser') bullets.splice(i, 1);

							if (b.type === 'shell') {
								spawnParticles(b.x, b.y, '#ffaa00', 8);
								shake = 2;
							} else {
								spawnParticles(b.x, b.y, '#fff', 1);
							}

							if (e.hp <= 0) {
								killEnemy(j);
							}
							break;
						}
					}

					if (b.type === 'shotgun') {
						for (let k = bullets.length - 1; k >= 0; k--) {
							const eb = bullets[k];
							if (!eb) continue;
							if (eb.owner === 'enemy' && Math.hypot(b.x - eb.x, b.y - eb.y) < 25) {
								bullets.splice(k, 1);
								spawnParticles(eb.x, eb.y, '#aaa', 3);
							}
						}
					}

				} else {
					if (player.invincible <= 0 && Math.abs(b.x - player.x) < 10 && Math.abs(b.y - player.y) < 15) {
						bullets.splice(i, 1);
						playerHit();
					}
				}
			}

			// Particles
			for (let i = particles.length - 1; i >= 0; i--) {
				const p = particles[i];
				p.x += p.vx; p.y += p.vy; p.life -= 0.05;
				if (p.life <= 0) particles.splice(i, 1);
			}

			// Floating Texts
			for (let i = floatingTexts.length - 1; i >= 0; i--) {
				const ft = floatingTexts[i];
				ft.y += ft.vy;
				ft.life -= 1;
				if (ft.life <= 0) floatingTexts.splice(i, 1);
			}
		}

		function fireBullet(x, y, vx, vy, color) {
			// Apply bullet speed multiplier based on difficulty
			bullets.push({
				x, y,
				vx: vx * bulletSpeedMult,
				vy: vy * bulletSpeedMult,
				w: 10, h: 10, color, owner: 'enemy'
			});
		}

		function killEnemy(idx) {
			const e = enemies[idx];
			spawnParticles(e.x, e.y, '#ffa500', 15);

			// Combo System
			combo++;
			comboTimer = COMBO_TIMEOUT;
			if (combo > maxCombo) maxCombo = combo;

			// Score multiplier based on combo
			let comboMult = 1.0;
			if (combo >= 50) comboMult = 3.0;
			else if (combo >= 25) comboMult = 2.0;
			else if (combo >= 10) comboMult = 1.5;

			// Show combo text at milestones
			if (combo === 10 || combo === 25 || combo === 50 || combo === 100) {
				spawnFloatingText(e.x, e.y - 30, `${combo} COMBO! x${comboMult}`, '#ffff00');
				SFX.upgrade();
			}

			if (e.type === 'boss') {
				SFX.explodeBoss();
				score += Math.floor(5000 * stage * comboMult);
				bossActive = false;
				spawnParticles(e.x, e.y, '#ff00ff', 100);
				shake = 50;
				document.getElementById('boss-ui').style.display = 'none';
				enemies = []; bullets = [];
				player.fuel = MAX_FUEL;

				// Start stage transition
				stage++;
				stageTransition = true;
				stageTransitionTimer = STAGE_TRANSITION_DURATION;
			} else if (e.type === 'miniboss') {
				SFX.explodeLarge();
				score += Math.floor(2000 * comboMult);
				spawnParticles(e.x, e.y, '#ff5500', 50);
				shake = 10;
				spawnPowerup(e.x, e.y, 'L');
			} else if (e.type === 'turret') {
				SFX.explodeLarge();
				score += Math.floor(300 * comboMult);
			} else {
				SFX.explodeSmall();
				score += Math.floor(100 * comboMult);
				if (e.isRed || Math.random() < 0.12) {
					const r = Math.random();
					let t = 'S';
					if (r < 0.2) t = 'S';
					else if (r < 0.4) t = '3';
					else if (r < 0.6) t = 'A';
					else if (r < 0.8) t = 'M';
					else t = 'side';
					if (Math.random() < 0.1) t = 'L';
					spawnPowerup(e.x, e.y, t);
				}
			}
			enemies.splice(idx, 1);
		}

		function playerHit() {
			SFX.playerHit();
			player.lives--;
			spawnParticles(player.x, player.y, '#ff0000', 60);
			flashScreen();
			shake = 20;

			if (player.lives < 0) {
				gameOver();
			} else {
				showCenterMsg("MAYDAY!");
				player.invincible = 120;
				if (player.weapons.length > 1) player.weapons.pop();
				else player.weapons[0].lv = 1;
				bullets = [];
			}
		}

		function spawnPowerup(x, y, type) {
			powerups.push({ x, y, type, scale: 1 });
		}

		function spawnFloatingText(x, y, text, color) {
			floatingTexts.push({ x, y, text, color, life: 60, vy: -1.5 });
		}

		function spawnParticles(x, y, color, count) {
			for (let i = 0; i < count; i++) {
				particles.push({ x, y, vx: (Math.random() - 0.5) * 12, vy: (Math.random() - 0.5) * 12, life: 1, color });
			}
		}

		function flashScreen() {
			const f = document.getElementById('flash');
			f.style.opacity = 0.5;
			setTimeout(() => f.style.opacity = 0, 50);
		}

		function showCenterMsg(text) {
			// Replaces previous
			const container = document.getElementById('msg-container');
			container.innerHTML = ''; // Clear old
			const div = document.createElement('div');
			div.innerText = text;
			div.className = 'center-msg';
			container.appendChild(div);
			setTimeout(() => { if (div.parentNode) div.remove(); }, 2500);
		}

		function updateBossBar(pct) {
			document.getElementById('boss-bar-fill').style.width = pct + '%';
		}

		function gameOver() {
			gameRunning = false;
			SFX.gameOver();
			if (score > hiscore) {
				hiscore = score;
				localStorage.setItem('endless_hiscore', hiscore);
			}
			document.getElementById('end-screen').classList.remove('hidden');
			document.getElementById('final-score').innerText = score;
			document.getElementById('final-combo').innerText = maxCombo;
			document.getElementById('final-stage').innerText = stage;

			// Show difficulty on end screen
			const preset = DIFFICULTY_PRESETS[currentDifficulty];
			const endDiff = document.getElementById('end-difficulty');
			endDiff.textContent = preset.name;
			endDiff.style.color = preset.color;
		}

		function draw() {
			if (!gameRunning) return requestAnimationFrame(draw);

			ctx.save();
			if (shake > 0) ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);

			// Sea BG
			const oceanColor = stage % 2 === 0 ? '#002244' : '#001133';
			ctx.fillStyle = oceanColor;
			ctx.fillRect(0, 0, width, height);
			ctx.fillStyle = 'rgba(255,255,255,0.05)';
			for (let i = 0; i < 15; i++) {
				let y = (bgOffset * 0.5 + i * 150) % (height + 200) - 200;
				ctx.fillRect(0, y, width, 40);
			}

			// Draw clouds (background layer)
			drawClouds(0.3);

			// DRAW GROUND UNITS UNDER PLAYER/AIR
			enemies.forEach(e => {
				if (e.type !== 'turret') return;
				ctx.save(); ctx.translate(e.x, e.y);

				// Island Base - Irregular shape
				ctx.fillStyle = '#c2b280'; // Sand
				ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.fill();
				ctx.fillStyle = '#228b22'; // Forest Green
				ctx.beginPath();
				ctx.moveTo(-20, -10);
				ctx.lineTo(10, -25);
				ctx.lineTo(25, 5);
				ctx.lineTo(10, 25);
				ctx.lineTo(-25, 15);
				ctx.fill();

				// Turret
				ctx.fillStyle = '#888';
				ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI * 2); ctx.fill();
				ctx.strokeStyle = '#444'; ctx.lineWidth = 2; ctx.stroke();
				// Gun
				ctx.fillStyle = '#444';
				ctx.save(); ctx.rotate(e.angle || 0);
				ctx.fillRect(0, -5, 28, 10); // Longer barrel
				ctx.restore();
				ctx.restore();
			});

			// Player
			if (Math.floor(frame / 4) % 2 === 0 || player.invincible === 0) {
				ctx.save(); ctx.translate(player.x, player.y);
				ctx.fillStyle = '#bbb';
				ctx.beginPath(); ctx.moveTo(0, -25); ctx.lineTo(-8, 20); ctx.lineTo(8, 20); ctx.fill();
				ctx.fillStyle = '#999';
				ctx.fillRect(-15, -10, 6, 30); ctx.fillRect(9, -10, 6, 30);
				ctx.fillStyle = '#ccc';
				ctx.beginPath(); ctx.moveTo(-30, 0); ctx.lineTo(30, 0); ctx.lineTo(0, 5); ctx.fill();
				ctx.fillStyle = '#00aaff';
				ctx.beginPath(); ctx.arc(0, -5, 5, 0, Math.PI * 2); ctx.fill();

				if (player.sideFighters > 0) {
					ctx.fillStyle = '#ffaa00';
					ctx.beginPath(); ctx.arc(-35, 10, 5, 0, Math.PI * 2); ctx.fill();
				}
				if (player.sideFighters > 1) {
					ctx.beginPath(); ctx.arc(35, 10, 5, 0, Math.PI * 2); ctx.fill();
				}
				ctx.restore();
			}

			// Air Enemies
			enemies.forEach(e => {
				if (e.type === 'turret') return; // Handled

				ctx.save(); ctx.translate(e.x, e.y);
				ctx.shadowBlur = 0;

				if (e.type === 'boss') {
					// Multi-Part Rendering
					// 1. Draw Main Hull
					const isCarrier = e.subType.includes("Carrier");
					const isBomber = e.subType.includes("Bomber");

					if (isBomber) {
						ctx.fillStyle = '#4a4';
						// Wing shape
						ctx.beginPath(); ctx.moveTo(0, -e.h / 2); ctx.lineTo(-e.w / 2, 0); ctx.lineTo(0, e.h / 2); ctx.lineTo(e.w / 2, 0); ctx.fill();
					} else {
						// Ship shape
						ctx.fillStyle = '#444'; // Hull
						ctx.beginPath(); ctx.moveTo(0, -e.h / 2 - 20); ctx.lineTo(-e.w / 2, -e.h / 4); ctx.lineTo(-e.w / 2, e.h / 2); ctx.lineTo(e.w / 2, e.h / 2); ctx.lineTo(e.w / 2, -e.h / 4); ctx.fill();

						// Deck
						ctx.fillStyle = isCarrier ? '#334433' : '#654321'; // Green for carrier, Wood for Battleship
						ctx.fillRect(-e.w / 2 + 5, -e.h / 2 + 10, e.w - 10, e.h - 20);

						// Flight lines
						if (isCarrier) {
							ctx.fillStyle = '#fff';
							ctx.fillRect(-5, -e.h / 2 + 20, 10, e.h - 40);
						}
					}

					// 2. Draw Parts
					if (e.parts) {
						e.parts.forEach(p => {
							ctx.save(); ctx.translate(p.x, p.y);

							if (p.t === 'turret_main') {
								ctx.fillStyle = '#888'; ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI * 2); ctx.fill();
								ctx.rotate(p.angle);
								ctx.fillStyle = '#222'; ctx.fillRect(-5, -25, 10, 30); // Barrel
								ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.strokeRect(-5, -25, 10, 30);
							}
							else if (p.t === 'turret_aa') {
								ctx.fillStyle = '#666'; ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
								ctx.rotate(p.angle);
								ctx.fillStyle = '#222'; ctx.fillRect(-3, -15, 6, 18);
							}
							else if (p.t === 'bridge') {
								ctx.fillStyle = '#556'; ctx.fillRect(-15, -30, 30, 60);
								ctx.fillStyle = '#000'; ctx.fillRect(-10, -10, 20, 5); // Windows
							}
							else if (p.t === 'propeller') {
								ctx.rotate(p.angle);
								ctx.fillStyle = 'rgba(255,255,255,0.5)';
								ctx.fillRect(-20, -2, 40, 4);
								ctx.fillRect(-2, -20, 4, 40);
							}
							ctx.restore();
						});
					}

					if (e.hp < e.maxHp * 0.5) {
						ctx.fillStyle = `rgba(100,100,100,${Math.random()})`;
						ctx.beginPath(); ctx.arc((Math.random() - 0.5) * e.w, (Math.random() - 0.5) * e.h, 20, 0, Math.PI * 2); ctx.fill();
					}

				} else if (e.type === 'miniboss') {
					// B-17 Flying Fortress Style
					ctx.fillStyle = '#556655'; // Olive Drab
					// Main Fuselage
					ctx.beginPath(); ctx.ellipse(0, 0, 15, 60, 0, 0, Math.PI * 2); ctx.fill();
					// Wings
					ctx.beginPath(); ctx.moveTo(-60, -10); ctx.lineTo(60, -10); ctx.lineTo(60, 10); ctx.lineTo(-60, 10); ctx.fill();
					// Tail
					ctx.beginPath(); ctx.moveTo(-20, -40); ctx.lineTo(20, -40); ctx.lineTo(0, -55); ctx.fill();

					// Cockpit
					ctx.fillStyle = '#88ccff';
					ctx.beginPath(); ctx.arc(0, 20, 5, 0, Math.PI * 2); ctx.fill();

					// Propellers (4)
					ctx.fillStyle = 'rgba(255,255,255,0.4)';
					const propTime = Date.now() / 50;
					[-40, -20, 20, 40].forEach(x => {
						ctx.save(); ctx.translate(x, 10);
						ctx.rotate(propTime);
						ctx.fillRect(-12, -2, 24, 4); ctx.fillRect(-2, -12, 4, 24);
						ctx.restore();
					});

				} else if (e.type === 'grey') {
					// Heavy Fighter (Me 110 style)
					ctx.fillStyle = '#777';
					ctx.beginPath(); ctx.ellipse(0, 0, 10, 25, 0, 0, Math.PI * 2); ctx.fill(); // Body
					ctx.fillRect(-30, -5, 60, 12); // Wing
					ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(0, 10, 3, 0, Math.PI * 2); ctx.fill(); // Prop

				} else if (e.type === 'red_formation') {
					// Red Ace (Zero style)
					ctx.fillStyle = '#cc0000';
					ctx.beginPath(); ctx.moveTo(0, 15); ctx.lineTo(-5, -20); ctx.lineTo(5, -20); ctx.fill(); // Fuselage
					ctx.beginPath(); ctx.moveTo(-15, -5); ctx.lineTo(15, -5); ctx.lineTo(0, 5); ctx.fill(); // Wing
					ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, -5, 3, 0, Math.PI * 2); ctx.fill(); // Hinomaru?

				} else {
					// Green Fighter (Zero/Hayabusa)
					ctx.fillStyle = '#336633';
					ctx.beginPath(); ctx.ellipse(0, 0, 6, 18, 0, 0, Math.PI * 2); ctx.fill(); // Body
					ctx.beginPath(); ctx.moveTo(-18, -2); ctx.lineTo(18, -2); ctx.lineTo(0, 5); ctx.fill(); // Wing
					ctx.fillStyle = '#d00'; // Roundels
					ctx.beginPath(); ctx.arc(-10, -2, 3, 0, Math.PI * 2); ctx.arc(10, -2, 3, 0, Math.PI * 2); ctx.fill();
					ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(0, 18, 2, 0, Math.PI * 2); ctx.fill(); // Prop
				}
				ctx.restore();
			});

			// Bullets - Make Enemy bullets more visible if needed (Red/Yellow used currently)
			bullets.forEach(b => {
				ctx.fillStyle = b.color;
				if (b.type === 'laser') {
					ctx.shadowBlur = 15; ctx.shadowColor = b.color;
					ctx.fillRect(b.x - b.w / 2, b.y, b.w, b.h);
				} else if (b.type === 'shotgun') {
					ctx.beginPath(); ctx.arc(b.x, b.y, b.w / 2, 0, Math.PI * 2); ctx.fill();
				} else if (b.type === 'shell') {
					ctx.shadowBlur = 10; ctx.shadowColor = '#ff0000';
					ctx.beginPath(); ctx.arc(b.x, b.y, b.w / 2, 0, Math.PI * 2); ctx.fill();
				} else {
					ctx.fillRect(b.x - b.w / 2, b.y - b.h / 2, b.w, b.h);
				}
				ctx.shadowBlur = 0;
			});

			// Powerups
			powerups.forEach(p => {
				ctx.fillStyle = ({
					'S': '#00ff00', '3': '#ffff00', 'A': '#ffffff',
					'M': '#ff5500', 'L': '#00ccff', 'side': '#ffaa00', '1UP': '#ff00ff'
				})[p.type] || '#fff';

				ctx.save(); ctx.translate(p.x, p.y); ctx.scale(p.scale, p.scale);
				ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill();
				ctx.lineWidth = 3; ctx.strokeStyle = '#000'; ctx.stroke();
				ctx.fillStyle = "#000"; ctx.font = "bold 20px Arial"; ctx.textAlign = 'center'; tx = p.type;
				if (p.type === 'side') tx = 'O';
				ctx.fillText(tx, 0, 7);
				ctx.restore();
			});

			// Particles
			particles.forEach(p => {
				ctx.globalAlpha = p.life;
				ctx.fillStyle = p.color;
				ctx.fillRect(p.x, p.y, 4, 4);
			});
			ctx.globalAlpha = 1;

			// Draw foreground clouds (enemies appear from behind)
			drawClouds(0.15);

			// Floating Texts
			floatingTexts.forEach(ft => {
				ctx.globalAlpha = Math.max(0, ft.life / 60);
				ctx.font = "bold 24px Impact";
				ctx.fillStyle = ft.color;
				ctx.strokeStyle = 'black';
				ctx.lineWidth = 4;
				ctx.textAlign = 'center';
				ctx.strokeText(ft.text, ft.x, ft.y);
				ctx.fillText(ft.text, ft.x, ft.y);
			});
			ctx.globalAlpha = 1;

			// Draw Combo Display
			if (combo > 0) {
				const comboX = width - 20;
				const comboY = 120;

				// Calculate current multiplier for display
				let displayMult = 1.0;
				if (combo >= 50) displayMult = 3.0;
				else if (combo >= 25) displayMult = 2.0;
				else if (combo >= 10) displayMult = 1.5;

				// Combo number with pulsing effect
				const pulse = 1 + Math.sin(frame * 0.2) * 0.1;
				ctx.save();
				ctx.translate(comboX, comboY);
				ctx.scale(pulse, pulse);

				// Combo count
				ctx.font = 'bold 36px Impact';
				ctx.textAlign = 'right';
				ctx.strokeStyle = '#000';
				ctx.lineWidth = 4;
				ctx.fillStyle = combo >= 50 ? '#ff00ff' : combo >= 25 ? '#ffaa00' : combo >= 10 ? '#ffff00' : '#ffffff';
				ctx.strokeText(`${combo}`, 0, 0);
				ctx.fillText(`${combo}`, 0, 0);

				// "COMBO" text
				ctx.font = 'bold 20px Impact';
				ctx.strokeText('COMBO', 0, 25);
				ctx.fillText('COMBO', 0, 25);

				// Multiplier
				if (displayMult > 1.0) {
					ctx.font = 'bold 18px Impact';
					ctx.fillStyle = '#00ffff';
					ctx.strokeText(`x${displayMult}`, 0, 48);
					ctx.fillText(`x${displayMult}`, 0, 48);
				}

				// Timer bar
				ctx.restore();
				const barWidth = 80;
				const barHeight = 6;
				const timerRatio = comboTimer / COMBO_TIMEOUT;
				ctx.fillStyle = 'rgba(0,0,0,0.5)';
				ctx.fillRect(comboX - barWidth, comboY + 35, barWidth, barHeight);
				ctx.fillStyle = timerRatio > 0.3 ? '#00ff00' : '#ff0000';
				ctx.fillRect(comboX - barWidth, comboY + 35, barWidth * timerRatio, barHeight);
			}

			ctx.restore();
		}

		// Cloud layer for depth effect
		function drawClouds(alpha) {
			ctx.globalAlpha = alpha;
			ctx.fillStyle = '#ffffff';
			const cloudSpeed = bgOffset * 0.8;
			for (let i = 0; i < 5; i++) {
				const x = ((i * 300 + cloudSpeed * 0.3) % (width + 200)) - 100;
				const y = ((cloudSpeed + i * 250) % (height + 300)) - 150;
				// Draw fluffy cloud shape
				ctx.beginPath();
				ctx.arc(x, y, 40, 0, Math.PI * 2);
				ctx.arc(x + 35, y - 10, 35, 0, Math.PI * 2);
				ctx.arc(x + 70, y, 40, 0, Math.PI * 2);
				ctx.arc(x + 35, y + 15, 30, 0, Math.PI * 2);
				ctx.fill();
			}
			ctx.globalAlpha = 1;
		}

		function loop() {
			if (!gameRunning) return;
			if (!paused) {
				update();
			}
			draw();
			if (stageTransition) {
				drawStageTransition();
			}
			if (bossWarning) {
				drawBossWarning();
			}
			if (paused) {
				drawPauseOverlay();
			}
			requestAnimationFrame(loop);
		}

		function drawPauseOverlay() {
			ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
			ctx.fillRect(0, 0, width, height);

			ctx.font = 'bold 64px Impact';
			ctx.fillStyle = '#FFFFFF';
			ctx.textAlign = 'center';
			ctx.fillText('PAUSED', width / 2, height / 2 - 50);

			ctx.font = '24px Arial';
			ctx.fillStyle = '#AAAAAA';
			ctx.fillText('æŒ‰ ESC æˆ– P ç¹¼çºŒ', width / 2, height / 2 + 20);
			ctx.fillText('WASD / æ–¹å‘éµ - ç§»å‹•', width / 2, height / 2 + 55);
			ctx.fillText('SPACE / Z - ç‰¹æ®ŠæŠ€èƒ½', width / 2, height / 2 + 85);
		}

		function drawBossWarning() {
			if (!bossWarning || !bossWarningData) return;

			const progress = 1 - (bossWarningTimer / BOSS_WARNING_DURATION);
			const flash = Math.sin(bossWarningTimer * 0.3) > 0;

			// Flashing red overlay
			if (flash) {
				ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
				ctx.fillRect(0, 0, width, height);
			}

			// Dark overlay
			ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
			ctx.fillRect(0, 0, width, height);

			// Red scan lines effect
			ctx.fillStyle = flash ? 'rgba(255, 0, 0, 0.1)' : 'rgba(255, 0, 0, 0.05)';
			for (let y = 0; y < height; y += 4) {
				ctx.fillRect(0, y, width, 2);
			}

			ctx.textAlign = 'center';

			// âš  WARNING âš  - Flashing
			const warningY = height / 2 - 100;
			ctx.font = 'bold 72px Impact';
			ctx.strokeStyle = '#000';
			ctx.lineWidth = 6;

			if (flash) {
				ctx.fillStyle = '#FF0000';
				ctx.shadowColor = '#FF0000';
				ctx.shadowBlur = 30;
			} else {
				ctx.fillStyle = '#AA0000';
				ctx.shadowBlur = 0;
			}

			ctx.strokeText('âš  WARNING âš ', width / 2, warningY);
			ctx.fillText('âš  WARNING âš ', width / 2, warningY);
			ctx.shadowBlur = 0;

			// Stage number
			ctx.font = 'bold 28px Impact';
			ctx.fillStyle = '#FFAA00';
			ctx.strokeText(`STAGE ${stage}`, width / 2, warningY + 50);
			ctx.fillText(`STAGE ${stage}`, width / 2, warningY + 50);

			// Boss name - Large with slide-in effect
			const slideIn = Math.min(1, progress * 3);
			const nameX = width / 2 + (1 - slideIn) * 300;

			ctx.font = 'bold 56px Impact';
			ctx.fillStyle = '#FFFFFF';
			ctx.strokeStyle = '#000';
			ctx.lineWidth = 4;
			ctx.strokeText(`ã€Œ${bossWarningData.name}ã€`, nameX, height / 2 + 20);
			ctx.fillText(`ã€Œ${bossWarningData.name}ã€`, nameX, height / 2 + 20);

			// Boss type - subtitle
			ctx.font = 'bold 24px Arial';
			ctx.fillStyle = '#AAAAAA';
			ctx.strokeText(bossWarningData.type, nameX, height / 2 + 60);
			ctx.fillText(bossWarningData.type, nameX, height / 2 + 60);

			// Mission text
			if (progress > 0.3) {
				ctx.font = '20px Arial';
				ctx.fillStyle = '#FFFF00';
				const missionText = bossWarningData.type.includes('Carrier') ? 'ä»»å‹™ï¼šæ“Šæ²‰æ•µæ–¹èˆªæ¯' :
					bossWarningData.type.includes('Battleship') ? 'ä»»å‹™ï¼šæ“Šæ²‰æ•µæ–¹æˆ°è‰¦' :
					bossWarningData.type.includes('Bomber') ? 'ä»»å‹™ï¼šæ“Šè½æ•µæ–¹è½Ÿç‚¸æ©Ÿ' :
					'ä»»å‹™ï¼šæ¶ˆæ»…æ•µæ–¹ç›®æ¨™';
				ctx.fillText(missionText, width / 2, height / 2 + 110);
			}

			// Progress bar at bottom
			const barWidth = width * 0.6;
			const barX = (width - barWidth) / 2;
			const barY = height - 60;
			ctx.fillStyle = 'rgba(255,255,255,0.2)';
			ctx.fillRect(barX, barY, barWidth, 8);
			ctx.fillStyle = '#FF0000';
			ctx.fillRect(barX, barY, barWidth * progress, 8);
		}

		function drawStageTransition() {
			if (!stageTransition) return;

			const progress = 1 - (stageTransitionTimer / STAGE_TRANSITION_DURATION);
			const stageData = STAGE_NAMES[Math.min(stage - 1, STAGE_NAMES.length - 1)];

			// Dark blue gradient background
			const gradient = ctx.createLinearGradient(0, 0, 0, height);
			gradient.addColorStop(0, '#000033');
			gradient.addColorStop(0.5, '#000066');
			gradient.addColorStop(1, '#000033');
			ctx.fillStyle = gradient;
			ctx.fillRect(0, 0, width, height);

			// Stars background
			ctx.fillStyle = '#ffffff';
			for (let i = 0; i < 50; i++) {
				const starX = (i * 137 + frame * 0.5) % width;
				const starY = (i * 89) % height;
				const size = (i % 3) + 1;
				ctx.globalAlpha = 0.3 + (Math.sin(frame * 0.1 + i) + 1) * 0.35;
				ctx.fillRect(starX, starY, size, size);
			}
			ctx.globalAlpha = 1;

			ctx.textAlign = 'center';

			// "STAGE CLEAR" or "MISSION START" text
			const titleY = height / 2 - 80;
			const isFirstStage = (stage === 1);

			if (progress < 0.3) {
				// First show "STAGE CLEAR" or "MISSION START"
				ctx.font = 'bold 48px Impact';
				ctx.strokeStyle = '#000';
				ctx.lineWidth = 4;

				if (isFirstStage) {
					ctx.fillStyle = '#00AAFF';
					ctx.shadowColor = '#00AAFF';
					ctx.shadowBlur = 20;
					ctx.strokeText('MISSION START', width / 2, titleY);
					ctx.fillText('MISSION START', width / 2, titleY);
				} else {
					ctx.fillStyle = '#00FF00';
					ctx.shadowColor = '#00FF00';
					ctx.shadowBlur = 20;
					ctx.strokeText('STAGE CLEAR!', width / 2, titleY);
					ctx.fillText('STAGE CLEAR!', width / 2, titleY);
				}
				ctx.shadowBlur = 0;
			} else {
				// Then show next stage info
				const fadeIn = Math.min(1, (progress - 0.3) * 2);
				ctx.globalAlpha = fadeIn;

				// Stage number
				ctx.font = 'bold 36px Impact';
				ctx.strokeStyle = '#000';
				ctx.lineWidth = 4;
				ctx.fillStyle = '#FFAA00';
				ctx.strokeText(`STAGE ${stage}`, width / 2, titleY - 20);
				ctx.fillText(`STAGE ${stage}`, width / 2, titleY - 20);

				// Stage name (Japanese)
				ctx.font = 'bold 64px Impact';
				ctx.fillStyle = '#FFFFFF';
				ctx.shadowColor = '#0088FF';
				ctx.shadowBlur = 15;
				ctx.strokeText(`ã€Œ${stageData.name}ã€`, width / 2, titleY + 50);
				ctx.fillText(`ã€Œ${stageData.name}ã€`, width / 2, titleY + 50);
				ctx.shadowBlur = 0;

				// Area name
				ctx.font = '24px Arial';
				ctx.fillStyle = '#AAAAAA';
				ctx.fillText(stageData.area, width / 2, titleY + 90);

				// Mission objective
				ctx.font = 'bold 28px Arial';
				ctx.fillStyle = '#FFFF00';
				ctx.strokeStyle = '#000';
				ctx.lineWidth = 3;
				ctx.strokeText(`ä»»å‹™ï¼š${stageData.mission}`, width / 2, height / 2 + 60);
				ctx.fillText(`ä»»å‹™ï¼š${stageData.mission}`, width / 2, height / 2 + 60);

				// Next boss preview
				if (stage <= BOSS_DATA.length) {
					const nextBoss = BOSS_DATA[stage - 1];
					ctx.font = '20px Arial';
					ctx.fillStyle = '#FF6666';
					ctx.fillText(`ç›®æ¨™ï¼š${nextBoss.name} (${nextBoss.type})`, width / 2, height / 2 + 100);
				}

				ctx.globalAlpha = 1;
			}

			// Countdown
			const secondsLeft = Math.ceil(stageTransitionTimer / 60);
			ctx.font = 'bold 24px Arial';
			ctx.fillStyle = '#FFFFFF';
			ctx.fillText(`${secondsLeft}`, width / 2, height - 80);

			// Progress bar
			const barWidth = width * 0.5;
			const barX = (width - barWidth) / 2;
			const barY = height - 50;
			ctx.fillStyle = 'rgba(255,255,255,0.2)';
			ctx.fillRect(barX, barY, barWidth, 6);
			ctx.fillStyle = '#00AAFF';
			ctx.fillRect(barX, barY, barWidth * progress, 6);

			// Instruction
			ctx.font = '16px Arial';
			ctx.fillStyle = '#888888';
			ctx.fillText('æº–å‚™ä¸‹ä¸€é—œ...', width / 2, height - 25);
		}
	</script>
</body>

</html>